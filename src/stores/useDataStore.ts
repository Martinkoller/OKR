import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import { OKR, KPI, AuditEntry, ActionPlan, Template, KPIStatus } from '@/types'
import {
  MOCK_OKRS,
  MOCK_ACTION_PLANS,
  MOCK_AUDIT_LOGS,
  MOCK_TEMPLATES,
} from '@/data/mockData'
import { calculateStatus, calculateOKRProgress } from '@/lib/kpi-utils'
import { useUserStore } from '@/stores/useUserStore'
import { kpiService } from '@/services/kpiService'

interface DataState {
  okrs: OKR[]
  kpis: KPI[]
  actionPlans: ActionPlan[]
  auditLogs: AuditEntry[]
  templates: Template[]
  isLoading: boolean

  fetchKPIs: () => Promise<void>

  updateKPI: (
    kpiId: string,
    value: number,
    userId: string,
    comment?: string,
    isRetroactive?: boolean,
    reason?: string,
    referenceDate?: string,
  ) => Promise<void>

  deleteKPIMeasurement: (
    kpiId: string,
    timestamp: string,
    userId: string,
  ) => void

  updateOKR: (okr: OKR, userId: string) => void

  saveActionPlan: (plan: ActionPlan, userId: string) => void
  deleteActionPlan: (planId: string, userId: string) => void

  addAuditEntry: (entry: Omit<AuditEntry, 'id' | 'timestamp'>) => void
  addOKR: (okr: OKR, userId: string) => void
  addKPI: (kpi: KPI, userId: string) => Promise<void>

  deleteOKR: (okrId: string, userId: string) => void
  deleteKPI: (kpiId: string, userId: string) => Promise<void>

  restoreOKR: (okrId: string, userId: string) => void
  restoreKPI: (kpiId: string, userId: string) => void

  addTemplate: (template: Template, userId: string) => void
  updateTemplate: (template: Template, userId: string) => void
  deleteTemplate: (templateId: string, userId: string) => void
}

export const useDataStore = create<DataState>()(
  persist(
    (set, get) => ({
      okrs: MOCK_OKRS,
      kpis: [], // Initial state empty, fetched from Supabase
      actionPlans: MOCK_ACTION_PLANS,
      auditLogs: MOCK_AUDIT_LOGS,
      templates: MOCK_TEMPLATES,
      isLoading: false,

      fetchKPIs: async () => {
        set({ isLoading: true })
        try {
          const kpis = await kpiService.fetchKPIs()
          set({ kpis })
        } catch (error) {
          console.error('Failed to fetch KPIs:', error)
        } finally {
          set({ isLoading: false })
        }
      },

      updateKPI: async (
        kpiId,
        value,
        userId,
        comment,
        isRetroactive,
        reason,
        referenceDate,
      ) => {
        const date = referenceDate || new Date().toISOString()

        try {
          await kpiService.addMeasurement(kpiId, value, userId, date, comment)
          // Refetch to sync state
          await get().fetchKPIs()

          // Add Audit Log locally for UI feedback (though it could be DB based too)
          get().addAuditEntry({
            entityId: kpiId,
            entityType: 'KPI',
            action: 'UPDATE',
            field: 'value',
            newValue: value,
            reason: comment || 'Update',
            userId,
          })
        } catch (error) {
          console.error('Failed to update KPI:', error)
        }
      },

      addKPI: async (kpi, userId) => {
        try {
          await kpiService.createKPI(kpi, userId)
          await get().fetchKPIs()

          get().addAuditEntry({
            entityId: kpi.id, // ID might differ if generated by DB, handling basic case
            entityType: 'KPI',
            action: 'CREATE',
            reason: `KPI Created: ${kpi.name}`,
            userId,
          })
        } catch (error) {
          console.error('Failed to create KPI:', error)
        }
      },

      deleteKPI: async (kpiId, userId) => {
        try {
          await kpiService.deleteKPI(kpiId)
          await get().fetchKPIs()

          get().addAuditEntry({
            entityId: kpiId,
            entityType: 'KPI',
            action: 'DELETE',
            reason: 'KPI Deleted',
            userId,
          })
        } catch (error) {
          console.error('Failed to delete KPI:', error)
        }
      },

      // ... Existing Logic for other entities (Mocked/Local) ...

      deleteKPIMeasurement: (kpiId, timestamp, userId) => {
        // Implement removal logic if API supports it, or keep local for now as User Story focused on Add/Update
        console.log('Delete measurement not fully implemented in DB layer yet')
      },

      updateOKR: (okr, userId) => {
        set((state) => {
          const oldOKR = state.okrs.find((o) => o.id === okr.id)
          const oldProgress = oldOKR?.progress

          const { progress, status } = calculateOKRProgress(okr, state.kpis)
          const updatedOKR = { ...okr, progress, status }

          const newOKRs = state.okrs.map((o) =>
            o.id === okr.id ? updatedOKR : o,
          )

          get().addAuditEntry({
            entityId: okr.id,
            entityType: 'OKR',
            action: 'UPDATE',
            field: 'progress',
            oldValue: oldProgress,
            newValue: progress,
            reason: `Atualização de OKR: ${okr.title}`,
            userId,
          })

          return { okrs: newOKRs }
        })
      },

      saveActionPlan: (plan, userId) => {
        set((state) => {
          // Keep existing logic for Action Plans (Mocked)
          const existingIndex = state.actionPlans.findIndex(
            (p) => p.id === plan.id,
          )
          let newPlans = [...state.actionPlans]

          if (existingIndex >= 0) {
            newPlans[existingIndex] = {
              ...plan,
              updatedAt: new Date().toISOString(),
            }
          } else {
            newPlans = [
              {
                ...plan,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
              },
              ...state.actionPlans,
            ]
          }
          return { actionPlans: newPlans }
        })
      },

      deleteActionPlan: (planId, userId) => {
        set((state) => ({
          actionPlans: state.actionPlans.filter((p) => p.id !== planId),
        }))
      },

      addAuditEntry: (entry) =>
        set((state) => ({
          auditLogs: [
            {
              ...entry,
              id: Math.random().toString(36).substr(2, 9),
              timestamp: new Date().toISOString(),
            },
            ...state.auditLogs,
          ],
        })),

      addOKR: (okr, userId) => {
        set((state) => ({
          okrs: [...state.okrs, okr],
        }))
      },

      deleteOKR: (okrId, userId) => {
        set((state) => ({
          okrs: state.okrs.filter((o) => o.id !== okrId),
        }))
      },

      restoreOKR: (okrId, userId) => {
        // Mock restore
      },

      restoreKPI: (kpiId, userId) => {
        // Mock restore
      },

      addTemplate: (template, userId) =>
        set((state) => ({ templates: [...state.templates, template] })),

      updateTemplate: (template, userId) =>
        set((state) => ({
          templates: state.templates.map((t) =>
            t.id === template.id ? template : t,
          ),
        })),

      deleteTemplate: (templateId, userId) =>
        set((state) => ({
          templates: state.templates.filter((t) => t.id !== templateId),
        })),
    }),
    {
      name: 'stratmanager-data-storage',
      partialize: (state) => ({
        // Don't persist KPIs as they come from DB now
        okrs: state.okrs,
        actionPlans: state.actionPlans,
        auditLogs: state.auditLogs,
        templates: state.templates,
      }),
    },
  ),
)
